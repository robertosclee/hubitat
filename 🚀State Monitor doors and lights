definition(
    name: "🚀State Monitor doors and lights",
    namespace: "RL",
    author: "Roberto Lee",
    description: "Monitors lights and doors. After a state change, waits 3 seconds, then sends a message with the list of lights that are on and doors that are open.",
    category: "Convenience",
    iconUrl: "",
    iconX2Url: ""
)

preferences {
    section("Settings") {
        input "groupChanges", "bool", title: "Group changes with a slight delay? Otherwise notify on every change", required: true
    }
    section("Select Devices to Monitor") {
        input "lights", "capability.switch", title: "Which lights?", multiple: true, required: false, width: 4
        input "doors", "capability.contactSensor", title: "Which doors?", multiple: true, required: false, width: 4
        input "motionsensors", "capability.motionSensor", title: "Which motion sensors?", multiple: true, required: false, width: 4
    }
    section("Manual Triggers") {
        input "manualLightsOffTrigger", "capability.switch", title: "All lights off trigger", multiple: false, required: true, width: 4
        input "manualCheckTrigger", "capability.switch", title: "Manual Motion Check Trigger", required: false, width: 4
        input "runInMinutes", "number", title: "Check every n minutes", required: true, defaultValue: 15, width: 4
    }

    section("Message Notification") {
        //input "sendPush", "bool", title: "Send Push Notification?", required: true, defaultValue: true, width: 3
        //input "sendSMS", "phone", title: "Send SMS Notification to this number (optional)", required: false, width: 3
        input "sendMessageLog", "capability.notification", title: "Send log", multiple: true, required: false, width: 6
        input "sendImportant", "capability.notification", title: "Send important phone notifications", multiple: true, required: false, width: 6
    }    
    section("Actions:") {
        input name: "Save", type: "button", title: "Save", submitOnChange: true
    }    
}

def logwarn(message, methodName ="") 
{
    if(methodName != "")
    {
        state.logPostfix = methodName
    }
    log.warn "[⚙️${state.logPrefix}] ${message} ➜${state.logPostfix}"
}


def logdebug(message, methodName ="") 
{
    if(methodName != "")
    {
        state.logPostfix = methodName
    }
    log.debug "[⚙️${state.logPrefix}] ${message} ➜${state.logPostfix}"
}

def loginfo(message, methodName ="") 
{
    if(methodName != "")
    {
        state.logPostfix = methodName
    }
    log.info "[⚙️${state.logPrefix}] ${message} ➜${state.logPostfix}"
}

def installed() 
{
    initialize()
}

def updated() 
{
    initialize()
}

def initialize() 
{
    def callMethod = "initialize"
    state.logPrefix = "watcher"
    unsubscribe()
    
    if (lights) {
        subscribe(lights, "switch", stateChangeHandler)
    }
    if (doors) {
        subscribe(doors, "contact", stateChangeHandler)
    }
    if (motionsensors) {
       subscribe(motionsensors, "motion", motionHandler)
    }
    if (manualCheckTrigger) 
    {
        subscribe(manualCheckTrigger, "switch.on", manualCheckHandler)
    }
    
    subscribe(manualLightsOffTrigger, "switch", manualLightsOffTriggerHandler)

    subscribe(location, "mode", modeChangeHandler)
    
    runIn(1, checkStateAndNotify, [data: [source: 'initialize']])

    // Schedule the check
    runIn(3, schedulerCheck)    
    
    loginfo("watcher engine restarted",callMethod)
}

def modeChangeHandler(evt) 
{
    def callMethod = "modeChangeHandler"
    logdebug("Mode changed to: ${evt.value}",callMethod)
    sendImportant.deviceNotification("Mode changed to: ${evt.value}\n#watcher")
    if (location.mode == "SleepAll")
    {
        def excludePartialNames = ["kids"]
        turnOffLightsExcept(excludePartialNames)
    }    
    if (location.mode == "Away")
    {
        def excludePartialNames = []
        turnOffLightsExcept(excludePartialNames)
    }        
}

def appButtonHandler(buttonName) 
{
    def callMethod = "appButtonHandler"
    logdebug("Button pressed: ${buttonName}", callMethod)
    if (buttonName == "testButton") 
    {
        runIn(1, checkStateAndNotify, [data: [source: 'test']])
    }
}

def manualCheckHandler(evt) 
{
    def callMethod = "manualCheckHandler"
    runIn(3, checkStateAndNotify, [data: [source: callMethod]])    
}


def manualLightsOffTriggerHandler(evt) 
{
    def callMethod = "manualLightsOffTriggerHandler"

    if (["SleepAll", "SleepSome"].contains(location.mode))
    {
        def excludePartialNames = ["kids"]
        turnOffLightsExcept(excludePartialNames)
    }    
    if (location.mode == "Away")
    {
        def excludePartialNames = []
        turnOffLightsExcept(excludePartialNames)
    }  
}

def motionHandler(evt) 
{
    def callMethod = "motionHandler"
    runIn(3, checkStateAndNotify, [data: [source: callMethod]])

    /*
    def motionActive = motionsensors ? motionsensors.findAll { it.currentMotion == "active" } : []
    motionActive.each { m ->
        //light.off() // Turns off the light
       // log.debug "${light.displayName} turned off"
    }    
    
    if(motionActive.size > 0 && ["SleepAll", "Away"].contains(location.mode))
    {
        def actives = motionActive.collect { it.displayName }.join("\n")
        if (sendMessageLog && (location.mode == "SleepAll" || location.mode == "Away")  ) 
        {
            sendMessageLog.deviceNotification("${location.mode}, \n${actives}")     
        }

        if(sendImportant && location.mode == "Away")
        {
            sendImportant.each { device ->
                if (device.hasCapability("Notification")) 
                {
                    device.deviceNotification("!!!${location.mode}, \n${actives}")
                    logdebug("Sent notification to ${device.displayName}",callMethod)
                } 
                else 
                {
                    logwarn("Device ${device.displayName} does not support notifications.",callMethod)
                }
            }  
        }    
    }
    */
}

def stateChangeHandler(evt) 
{
    def callMethod = "stateChangeHandler"
    
    logdebug("State changed: ${evt.displayName} is ${evt.value}",callMethod)
    if(groupChanges)
    {
        runIn(3, checkStateAndNotify, [data: [source: callMethod]])    
    }    
    else
    {
        sendMessageLog.deviceNotification("${evt.value == "off" ? "❌" : ""} ${evt.displayName}")
    }
}


def schedulerCheck(data) 
{
    def callMethod = "schedulerCheck"
    def source = data?.source ?: "unknown"    

    unschedule()
    //runIn(3, checkStateAndNotify, [data: [source: 'schedulerCheck']])
    //runIn(60*runInMinutes, schedulerCheck) //EVERY 15 MIN
    runIn(60*runInMinutes, schedulerCheck, [data: [source: callMethod]]) //EVERY 15 MIN
}

def checkStateAndNotify(data) 
{
    def callMethod = "checkStateAndNotify"
    
    def source = data?.source ?: "unknown"
    //log.debug "checkStateAndNotify called by: ${source}"
    
    def lightsOn = lights ? lights.findAll { it.currentSwitch == "on" }.sort { a, b -> a.displayName <=> b.displayName } : []
    def openDoors = doors ? doors.findAll { it.currentContact == "open" }.sort { a, b -> a.displayName <=> b.displayName } : []
    def motionActive = motionsensors ? motionsensors.findAll { it.currentMotion == "active" }.sort { a, b -> a.displayName <=> b.displayName } : []
   
    def lightNames = lightsOn.collect { it.displayName }.join("\n")
    def doorNames = openDoors.collect { it.displayName }.join("\n")
    def motionNames = motionActive.collect { it.displayName }.join("\n")

    def message = "💡:${lightsOn.size()}/${lights.size()} 🚪:${openDoors.size()}/${doors.size()}  👋:${openDoors.size()}/${motionsensors.size()}\n"
    def messagedoors = "🚪:${openDoors.size()}\n"
    def messagelights = "💡:${lightsOn.size()}\n"
    def messagemotions = "👋:${motionNames.size()}\n"
    if (lightsOn) 
    {
        message += "${lightNames}\n"
        messagelights += "${lightNames}\n"
    }
    if (openDoors) 
    {
        message += "${doorNames}\n"
        messagedoors += "${doorNames}\n"
    }
    if (messagemotions) 
    {
        message += "${motionNames}\n"
        messagemotions += "${motionNames}\n"
    }    

    if (message) 
    {
        //message += " | watching total of ${lights.size()} lights, ${doors.size()} doors, ${motionsensors.size()} motion sensors\n"        
		message += "#watcher #${source}"
        /*
        if (sendPush) 
        {
            log.debug "sendPush"
            sendPush(message)
        }
        if (sendSMS) 
        {
            sendSms(sendSMS, message)
        }
        */
        if (sendMessageLog) 
        {
            //log.debug "sendMessageLog"
            sendMessageLog.deviceNotification(message)
        }
        /*
        if (sendImportant && source == "test" && (lightsOn.size() > 0 || openDoors.size() > 0) ) {
            log.debug "sendImportant"
            sendImportant.deviceNotification(message)
        }
        */
        //STATE CHANGED TO IDLE, NOTIFY ONCE
        if((lightsOn.size() == 0 && openDoors.size() == 0) && state.somethingwasonoropen == true)
        {
            state.somethingwasonoropen = false
            sendImportant.each { device ->
                //log.debug "Sending notification to ${device.displayName}"
                if (device.hasCapability("Notification")) 
                {
                    device.deviceNotification(message)
                    logdebug("Sent notification to ${device.displayName}",callMethod)
                } 
                else 
                {
                    logwarn("Device ${device.displayName} does not support notifications.",callMethod)
                }
            }             
        }
        
        if(source == "scheduleCheck" && (lightsOn.size() > 0 || openDoors.size() > 0))
        {
            if(lightsOn.size() > 0)
            {
                state.somethingwason = true
            }
            if(openDoors.size() > 0)
            {
                state.somethingwasopen = true
            }
                        
            sendMessageLog.each { device ->
                if (device.hasCapability("Notification")) 
                {
                    device.deviceNotification(message)
                    logdebug("Sent notification to ${device.displayName}",callMethod)
                } 
                else 
                {
                    logwarn("Device ${device.displayName} does not support notifications.",callMethod)
                }
            }        
        }
        
        
        if(
            ( location.mode == "Away" && (lightsOn.size() > 0 || openDoors.size() > 0 || motionActive.size() > 0 ) )
            ||
            ( ["SleepAll", "Away"].contains(location.mode) && openDoors.size() > 0 )
        )
        {
            state.somethingwasonoropen = true
            sendImportant.each { device ->
                if (device.hasCapability("Notification")) 
                {
                    device.deviceNotification("MODE: ${location.mode.toUpperCase()}, BUT \n${message}")
                    logdebug("SLEEPING/AWAY? ${location.mode} \n${messagedoors}, Sent notification to ${device.displayName}",callMethod)
                } 
                else 
                {
                    logwarn("Device ${device.displayName} does not support notifications.",callMethod)
                }
            }        
        }        
        loginfo(message,callMethod)
    } 
    else 
    {
        loginfo("No lights on or doors open.",callMethod)
    }
}

def turnOffLightsExcept(excludePartialNames = []) 
{
    def callMethod = "turnOffLightsExcept"
    
    def lightsOn = lights ? lights.findAll { 
        it.currentSwitch == "on" && 
        !excludePartialNames.any { partial -> it.displayName.contains(partial) }
    }.sort { a, b -> a.displayName <=> b.displayName } : []
    
    def lightsOnNames = lightsOn.collect { it.displayName }.join(", ")
    def exceptNames = excludePartialNames.size > 0 ? ", except ${excludePartialNames.collect { it }.join(", ")}" : ""

    loginfo("Turning off ${lightsOn.size} of ${lights.size()} lights in house${exceptNames}",callMethod) 
    sendMessageLog.deviceNotification("Turning off ${lightsOn.size} of ${lights.size()} lights in house${exceptNames}\n${lightsOnNames}\n#watcher")    
    
    lightsOn.each { light ->
        logdebug("Turning off ${light.displayName}",callMethod)
        light.off() 
    } 
}
