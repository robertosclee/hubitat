definition(
    name: "Lights Automations V1 Child",
    namespace: "RSCL_LA",
    parent: "RSCL_LA:Lights Automations V1",
    author: "Roberto Lee",
    description: "A parent app that creates and manages child apps.",
    category: "Convenience",
    iconUrl: "",
    iconX2Url: ""
)

preferences {
    page(name: "mainPage", title: "RSCL Child App Configuration", install: true, uninstall: true) 
}



Map mainPage() {
	dynamicPage(name: "mainPage", title: "", uninstall: true, install: true) {
	def includedModes = parent?.includedModes() ?: []
    //rearrangeModes()
        
    def states = allStates()
    //state.remove("configHistory")        
    //state.remove("usedConfigHistory")  

section("BASIC SETTINGS", hideable: true, hidden: true) 
{
paragraph """<style>
table           { border-collapse: collapse;border: 1px solid black;padding: 0;margin: 0;}
th, td          { border: 1px solid black;padding: 4px 2px 2px 2px;text-align: left;font-size:88%;}
th              { padding: 2px;background-color: #f2f2f2; }
table.noborder,table.noborder th, table.noborder td     {border: 0px solid black;padding: 0px;margin: 0px;}

.ninja          {display:none;}

.mdl-cell       {margin: 5px !important;}

.mdl-button,.mdl-button--raised,.mdl-shadow--2dp { -webkit-box-shadow: none !important; -moz-box-shadow: none !important; box-shadow: none !important; border: 1px solid #e1e1e1;}

.mdl-textfield__input { border-bottom: 1px solid rgb(221 207 207 / 32%); }

.btn-group-lg>.btn, .btn-lg { padding: 5px 8px; }

div[id^="collapse"] > div > div > div.inputdivider
{
/*background-color: #336699; */
margin-bottom: 5px; margin-top: 5px; border-bottom: 1px dashed #336699; height: 1px;
}

div[id^="collapse"] > div:last-child > div > div.inputdivider {background-color: #FFF; border-bottom: 0px dashed #eee; }

button.submitOnChange  {padding: 0 5px;}

div.statename   { width: 100px; float: left; border-bottom: 1px dotted #000;}

.yellow         { background-color: yellow; }

.grey           { background-color: grey; }
</style>"""       
    input "appName", "text", title: "Name", submitOnChange: true
    if(appName) app.updateLabel(appName)

    input "aboutRoom", "enum", title: "Select room", options: ["h", "lr", "mb", "g", "k", "s", "w", "o", "d", "test"], required: true, width: 3
    input "appEnabled", "bool", title: "Enable app?", defaultValue: true, width: 3
    input "enableManual", "bool", title: "Allow manually override. After turning on lights. No automation active until lights are turned off.", defaultValue: true, width: 3
    
    /*
    input "txtEnable", "bool", title: "Descriptive logging?", defaultValue: true, required: true, width: 4
    input "logEnable", "bool", title: "Extensive (debug) logging?", required: true, width: 4

    
    //input "includedModes", "mode", title: "Applicable modes", multiple: true, required: false, width: 6
    input "sendMessageLog", "capability.notification", title: "Send log", multiple: true, required: false, width: 6
    input "sendImportant", "capability.notification", title: "Send important phone notifications", multiple: true, required: false, width: 6    
	*/
    
    input name: "Save", type: "button", title: "Save", submitOnChange: true , width: 3   
}

def prefixInfo = "Room: <b>${aboutRoom}</b>, Mode: <b>${getMode()}</b>, Real: ${location.mode}, ${includedModes?.size()} modes: ${includedModes} "       
if(allMotionSensors())
{
    prefixInfo += "<br/>Last motion: ${getFormatted(state.lastmotiondt)} by ${state.lastmotionby}"
    prefixInfo += "<br/>Any motion: <b>${isAnyMotionActive(allMotionSensors())}</b>"
}


prefixInfo += "<br/>Any lights on: <b>${isAnySwitchOn(allLights())}</b>"
if(isAnySwitchOn(allLights()))        
{
    prefixInfo += ", turning off at ${state.turnofftime > nowDtStr() ? getFormatted(state.turnofftime) : ""}, stayon: ${state.cfgStayon}s"
    prefixInfo += ", was turned on manually <b>${state.turnedonmanually}</b> and has been skipped <b>${skippedTurningOff}</b> times"
}
        
section("DEVICES", hideable: true, hidden: false) 
{
    paragraph "${prefixInfo}"
    def dtFormat = "HH:mm:ss.SSS" //'yyyy-MM-dd HH:mm:ss.SSS'
    def statesDevices = ""
    lightGroupArray().each { grp ->
        statesDevices = ""
        grp.devices.each{d -> statesDevices += "${d.latestState("switch")?.date.format(dtFormat)} (${humanizeDatetime(d.latestState("switch")?.date)}) "}
        input "${grp.id}", "capability.switchLevel", title: "${grp.description} <br/>${isAnySwitchOn(grp.devices) ? '<span class="yellow"><b>on</b>' : '<span><b>off</b>'} since ${statesDevices}, ${grp.devices.collect { it.currentValue("level") + "%" }.join(", ")}</span>", required: false, multiple: true, width: 6
        //paragraph "${ humanizeDatetime(getLatestStatesSortedByTime(grp[2], "switch").time) }"
    }    

    statesDevices = ""
    motionSensorsTurnOn.each{d -> statesDevices += "${d.latestState("motion")?.date.format(dtFormat)} (${humanizeDatetime(d.latestState("motion")?.date)}) "}
    input "motionSensorsTurnOn", "capability.motionSensor", title: "'Turn on' motion sensors<br/>${isAnyMotionActive(motionSensorsTurnOn) ? '<span class="yellow"><b>active</b>' : '<span><b>inactive</b>'} since ${statesDevices}</span>", required: false, multiple: true, width: 6
    
    statesDevices = ""
    motionSensorsKeepOn.each{d -> statesDevices += "${d.latestState("motion")?.date.format(dtFormat)} (${humanizeDatetime(d.latestState("motion")?.date)}) "}
    input "motionSensorsKeepOn", "capability.motionSensor", title: "'Keep on' motion sensors<br/>${isAnyMotionActive(motionSensorsKeepOn) ? '<span class="yellow"><b>active</b>' : '<span><b>inactive</b>'} since ${statesDevices}</span>", required: false, multiple: true, width: 6

    statesDevices = ""
    roomDoors.each{d -> statesDevices += "${d.latestState("contact")?.date.format(dtFormat)} (${humanizeDatetime(d.latestState("contact")?.date)}) "}
    input "roomDoors", "capability.contactSensor", title: "Room doors<br/>${isAnyContactOpen(roomDoors) ? '<span class="yellow"><b>open</b>' : '<span><b>closed</b>'} since ${statesDevices}</span>", required: false, multiple: true, width: 6
    
    statesDevices = ""
    houseDoors.each{d -> statesDevices += "${d.latestState("contact")?.date.format(dtFormat)} (${humanizeDatetime(d.latestState("contact")?.date)}) "}    
    input "houseDoors", "capability.contactSensor", title: "House doors<br/>${isAnyContactOpen(houseDoors) ? '<span class="yellow"><b>open</b>' : '<span><b>closed</b>'} since ${statesDevices}</span>", required: false, multiple: true, width: 6    

    def isConsideredDark = isSwitchOn(isDarkSwitch) || luxSensor?.currentIlluminance < luxThreshold 
    statesDevices = ""
    statesDevices += "switch <b>${boolToYesNo(isSwitchOn(isDarkSwitch))}</b>, low illum. <b>${boolToYesNo(luxSensor?.currentIlluminance < luxThreshold)}</b>"
    paragraph "Is dark? ${isConsideredDark ? '<span class="yellow"><b>yes</b>' : '<span><b>no</b>'}</span><br/>${statesDevices}", width: 3
    
    statesDevices = ""
	statesDevices += "${isDarkSwitch?.latestState("switch")?.date?.format(dtFormat)} (${humanizeDatetime(isDarkSwitch?.latestState("switch")?.date)}) "
    input "isDarkSwitch", "capability.switch", title: "IsDark Switch<br/>${isSwitchOn(isDarkSwitch) ? '<span class="yellow"><b>on</b>' : '<span><b>off</b>'} since ${statesDevices}</span>", required: false, width: 3
    
    statesDevices = ""
	statesDevices += "${luxSensor?.latestState("illuminance")?.date?.format(dtFormat)} (${humanizeDatetime(luxSensor?.latestState("illuminance")?.date)}) "    
    input "luxSensor", "capability.illuminanceMeasurement", title: "Lux sensor<br/>measured: <b>${luxSensor?.currentIlluminance}</b> since ${statesDevices}", required: false, width: 3
    
    input "luxThreshold", "number", title: "Lux Threshold", required: false, defaultValue: 50, width: 3

    //input "socketPlug", "capability.powerMeter", title: "Select socket plug, power in watts <b>measured: ${states.socketPlugPower}, is using power: ${states.isSocketPlugUsingPower}</b>", required: false
    //input "powerThreshold", "number", title: "Power threshold for it to be considered on (watts), <b>measured: ${states.socketPlugPower}, is using power: ${states.isSocketPlugUsingPower}</b>", required: false, defaultValue: 55

    input "turnOnButtons", "capability.pushableButton", title: "Which buttons turnon?", required: false, multiple: true

    input name: "Save", type: "button", title: "Save", submitOnChange: true, width: 1
    input name: "AllLightsOff", type: "button", title: "All lights off", submitOnChange: true, width: 1
}

        section("STATES ALL", hideable: true, hidden: true)
        {
            def allstate = "<table>"
            allstate += "<tr><th colspan='3'>OWN</th></tr>"
            states.each { key, value ->
                allstate += "<tr><td>${key}</td><td colspan='2'>${states[key]}</td></tr>"
            }        
            allstate += "<tr><th colspan='3'>HUBITAT</th></tr>"
            state.each { key, value ->
                //state[key] = null // Reset each state variable to null
                //allstate += "${key} : ${state[key]} = ${  (state[key]  instanceof Date)  }\n" 
                
                
                if(key == "usedConfigHistory")
                {
                    state[key].eachWithIndex{ cfgHistory, index ->
                        allstate += "<tr><td>${index}</td><td>${cfgHistory.name}</td><td>${getFormatted(cfgHistory.time)}</td></tr>"
                    }
                }
                else
                {
                    allstate += "<tr><td>${key}</td><td colspan='2'>${state[key]}</td></tr>"
                }
            }
        
            allstate += "</table>";
            paragraph "<br/>All state:\n${allstate}"
        }

        section("Mode Configurations", hideable: true, hidden: false) {
            input "sourceMode", "enum", title: "Select Source Mode", options: includedModes, required: false, width: 3
            input "targetMode", "enum", title: "Select Target Mode", options: includedModes, required: false, width: 3
            input "Save", "button", title: "Save", submitOnChange: true, width: 2
            input "copyButton", "button", title: "Copy Configurations", submitOnChange: true, width: 2
            input "deleteButton", "button", title: "Delete target Configurations", submitOnChange: true, width: 2
        }         

        includedModes.each { mode ->
            section(mode == getMode() ? "<b>Mode: ${mode}</b>" : "Mode: ${mode}", class: "grey", hideable: true, hidden:  mode == getMode() ? false : false) 
            {
                paragraph "${prefixInfo}"
                
                lightGroupArray().each { grp -> 
                    if(grp.devices)
                    {
                        def devicesRelatedToGrp = "<span>"+grp.description+"</span>"
                        if(isAnySwitchOn(grp.devices))
                        {
                            devicesRelatedToGrp = "<span class='yellow'>${grp.description} = ${grp.devices.collect { it.currentValue("level") + "%" }.join(", ")}</span>"
                        }
                        
                        
                        if(devicesRelatedToGrp)
                        {
                            paragraph "<u>${devicesRelatedToGrp}</u><br/>"
                            
                            stateGroupArray().each { s ->
                            
                                def nms = getConfig(mode, grp.id, s.id)
                                if(s.devices)
                                {
                                    input "${nms.do}", "bool", title: "<div class='statename ${states.isRoomState == s.id ? "yellow" : ""}'>${boolToIcon(s.matchnow)} ${nms.statedescription} ${boolToArrowIcon(states.isRoomState == s.id)}</div> ${nms.values.do ? boolToOnOff(nms.values.turnon) : ""} ${nms.values.forcechange ? " for ${nms.values.stayon}s at ${nms.values.brightness}%" : ""}  ", required: false, defaultValue: false, width: 12
                                }
                                
                            }                
                        }
                    }


                }
                input name: "Save", type: "button", title: "Save", submitOnChange: true, width: 1  
                input name: "AllLightsOff", type: "button", title: "All lights off", submitOnChange: true, width: 3
            }
                
            
            section(mode == getMode() ? "<b>Mode: ${mode} configurations</b>" : "Mode: ${mode} configurations", hideable: true, hidden: mode == getMode() ? false : true) 
            {
                lightGroupArray().each { grp -> 
                    if(grp.devices)
                    {
                        def devicesRelatedToGrp = "<span>"+grp.description+"</span>"
                        if(isAnySwitchOn(grp.devices))
                        {
                            devicesRelatedToGrp = "<span class='yellow'>${grp.description} = ${grp.devices.collect { it.currentValue("level") + "%" }.join(", ")}</span>"
                        }
                        paragraph "<u>${devicesRelatedToGrp}</u><br/>"
                        
                        stateGroupArray().each { s ->
                            def nms = getConfig(mode, grp.id, s.id)

                            if(nms.values.do)
                            {
                                paragraph "<b class='${states.isRoomState == s.id ? "yellow" : ""}'>${boolToIcon(s.matchnow)} ${nms.title} ${boolToArrowIcon(states.isRoomState == s.id)}</b>", width: 2
                                input "${nms.turnon}", "bool", title: "turn on? <code class='ninja yellow'>${nms.turnon}</code>", required: false, defaultValue: false, width: 2
                                if(nms.values.turnon)
                                {
                                    input "${nms.forcechange}", "bool", title: "force settings? <code class='ninja yellow'>${nms.forcechange}</code>", required: false, defaultValue: false, width: 2
                                    input "${nms.stayon}", "number", title: "stay on in seconds <code class='ninja yellow'>${nms.stayon}</code>", required: true, defaultValue: 30, width: 2
                                    input "${nms.brightness}", "number", title: "brightness (0-100) <code class='ninja yellow'>${nms.brightness}</code>", required: true, defaultValue: 88, width: 2
                                    input "${nms.color}", "color", title: "color <code class='ninja yellow'>${nms.color}</code>", required: false, defaultValue: "#ffffff", width: 1
                                }

                                input name: "Save", type: "button", title: "Save", submitOnChange: true, width: 1   
                                paragraph "<div class='inputdivider'>&nbsp;</div>"
                            }
                            

                        }
                    }
                    
                    
                }
                
            }
        } 
        
	}
}


/*
def rearrangeModes() {
    if (includedModes && location.mode) {
        //def currentMode = location.mode
        def currentMode = getMode()
        includedModes = includedModes.findAll { it != currentMode } // Remove current mode if it exists
        includedModes = [currentMode] + includedModes // Add current mode to the beginning
    }
}
rearrangeModes()
*/

void updated() 
{
	initialize()
}

void installed() 
{
	initialize()
}

def initialize() 
{
    if(aboutRoom)
    {
        setAppname(settings.aboutRoom)
    }
    
    setCallMethod("initialize")

    linfo("initializing...")
    unschedule()
	unsubscribe()
    
    /*
    settings.each { key, _ ->
        app.removeSetting(key)
    }
    log.info "All settings have been removed."    
    
    //state.clear()  // Clears all entries from the state map
    state.each { key, _ ->
        state.remove(key)  // Remove the key-value pair from the state
    }
    log.info "All states have been cleared."
    */
    
	
    if (!appEnabled) {
        linfo("DISABLED...")
        return
    }

    linfo("ENABLED...")

    ldebug("subscribing ${location}")
    subscribe(location, "mode", modeHandler)

    ldebug("subscribing ${isDarkSwitch}")
    subscribe(isDarkSwitch, "switch", darkSwitchHandler)

    if(luxSensor)
    {
        ldebug("subscribing ${luxSensor}")
        subscribe(luxSensor, "illuminance", luxChangedHandler)
    }    
    if(roomDoors)
    {
        ldebug("subscribing ${roomDoors}")
        subscribe(roomDoors, "contact", roomDoorsHandler)
    }
    if(houseDoors)
    {
        ldebug("subscribing ${houseDoors}")
        subscribe(houseDoors, "contact", houseDoorsHandler)
    }
    if(turnOnButtons)
    {
        ldebug("subscribing ${turnOnButtons}")
        subscribe(sensor, "pushed", manualLightsOnHandler)
        subscribe(sensor, "doubleTapped", manualLightsOnHandler)
        subscribe(sensor, "held", manualLightsOnHandler)

        subscribe(turnOnButtons, "pushed", buttonTurnOnPushedHandler)
        subscribe(turnOnButtons, "doubleTapped", buttonTurnOnDoubleTappedHandler)
        subscribe(turnOnButtons, "held", buttonTurnOnHeldHandler)
    }

    lightGroupArray().each { grp -> 
        if(grp.devices)
        {
            ldebug("subscribing ${grp.devices}")
            subscribe(grp.devices, "switch", lightSwitchHandler)
        }
    }

    if(motionSensorsTurnOn)
    {
        motionSensorsTurnOn.each { sensor ->
            ldebug("subscribing ${sensor}")
            //subscribe(sensor, "motion.active", manualLightsOnHandler)            
            subscribe(sensor, "motion.active", motionTurnOnHandler)
            subscribe(sensor, "motion.inactive", motionStopTurnOnHandler)
        }
    }
    if(motionSensorsKeepOn)
    {
        motionSensorsKeepOn.each { sensor ->
            ldebug("subscribing ${sensor}")
            subscribe(sensor, "motion.active", motionKeepOnHandler)
            subscribe(sensor, "motion.inactive", motionStopKeepOnHandler)
        }
    }
    ldebug ("events subscriptions added")

    sendLog("App is initialized")
}


//EVENTS SUBSCRIPTIONS START
def lightSwitchHandler(evt) //WHEN LIGHTS TURNED ON BY AUTOMATION OR MANUALLY
{
    setCallMethod("lightSwitchHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    linfo("${deviceName} to <b>${deviceStatus}</b>")

    //DETERMINE IF LIGHTS ARE TURNED ON MANUALLY
    if(deviceStatus == "on" && enableManual)
    {
        def thresholdDetermineIfAutomation = 1000 //MS
        ldebug("last automation (${atomicState.automationLightsOn}) and now ${new Date().time}")
        def elapsedTime = new Date().time - atomicState.automationLightsOn
        def elapsedTimeInSeconds = elapsedTime / (1000)
        def elapsedTimeInMinutes = elapsedTime / (1000) / 60

        ldebug("elapsed ms: ${elapsedTime}, sec : ${elapsedTimeInSeconds} , min: ${elapsedTimeInMinutes}")
        //ldebug("elapsedTime since last automation (${state.atomicState.automationLightsOn}) and now ${nowDt()}: ${elapsedTime}ms, likely ${  elapsedTime > thresholdDetermineIfAutomation ? "manually" : "automation"  } = ${elapsedTimeInMinutes}min")
        def logElapsed = "${elapsedTime}ms (elapsed) > ${thresholdDetermineIfAutomation}ms (threshold)"
        if(elapsedTime > thresholdDetermineIfAutomation)
        {
            sendLog("manually via voice/button, ${logElapsed}")
            state.turnedonmanually = true
            state.skippedTurningOff = 0
        }
        else
        {
            sendLog("automated, ${logElapsed}")
        }
    }
    else
    {
        ldebug("device ${deviceName} to ${deviceStatus}, automation is active")
        if(state.turnedonmanually)
        {
            sendLog("Turned manually is false again. Lights automation is active again")
        }

        state.turnedonmanually = false
        state.skippedTurningOff = 0
    }    

    if(deviceStatus == "off")
    {
        ldebug("lights off, removing ${device?.id}")
        parent?.removeLightState(device?.id)
    }

    if(!enableManual)
    {
        state.turnedonmanually = false
        state.skippedTurningOff = 0
    }
    
}

def manualLightsOnHandler(evt) 
{
    setCallMethod("manualLightsOnHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    def deviceClass = evt.class
}

def modeHandler(evt) 
{
    setCallMethod("modeHandler")
    state.modeJustChanged = true
    def newMode = evt.value
    linfo("Mode changed to ${newMode}")
    if(getMode() != newMode)
    {
        linfo("Mode stays ${getMode()}, because of test")
    }
    //if(  ["SleepAll", "Away"].contains(getMode())  ||  ["SleepSome"].contains(getMode()) && ["h","mb"].contains(aboutRoom) )
    if(   (isAboutRoom("h,mb") && isAboutMode("SleepSome")) || isAboutMode("SleepAll,Away")    )
    {
        turnOffAllLights(true)
        linfo("mode changed to ${getMode()}, all lights off")
    }
    else
    {
        if(isAnySwitchOn(allLights()))        
        {
            //DO NOTHING
            //roomsHandler()

        }
    }
}




def luxChangedHandler(evt) 
{
    setCallMethod("luxChangedHandler")
    /*
    def anylightson = isAnySwitchOn(mainlights)
    logdebug ("lux level ${evt?.displayName} (virt: ${isVirtual(evt?.device)}) changed to ${evt.value}, threshold is ${luxThreshold}, any lights on: ${anylightson}", "luxChangedHandler")
    if(anylightson)
    {
        logdebug "some lights are on"
        if (evt?.device.currentIlluminance >= luxThreshold) {
            logdebug "${isVirtual(evt?.device) ? "virtual" : "real"} lux is now above threshold, turning off lights if no motion."
           // extendSchedule(getStayOnState(), turnOffIfInactive)
        }
    }
*/
    
    if(aboutRoom == "h")
    {
        //handleHallway()
    }        
    
}

def darkSwitchHandler(evt) 
{
    setCallMethod("darkSwitchHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    linfo("darkSwitch ${deviceName} to <b>${deviceStatus}</b>")

    if(isAnySwitchOn(allLights()))
    {
        roomsHandler()
    }
}

def roomDoorsHandler(evt) 
{
    doorHandler(evt, "roomDoorsHandler")
}

def houseDoorsHandler(evt) 
{
    doorHandler(evt, "houseDoorsHandler")
}

def doorHandler(evt, m)
{
    setCallMethod("${m} > doorHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value    
    ldebug("${deviceName} <b>${isContactOpen(device) ? "OPEN" : "DICHT"}</b> : <b>${deviceStatus}</b>")
    //if(isContactOn(evt.device))
    roomsHandler()     
}


def motionTurnOnHandler(evt) 
{
    motionHandler(evt)

    //ONLY HANDLE LIGHTS IF ALL LIGHTS ARE OFF
    if(!isAnySwitchOn(allLights()))
    {
        roomsHandler()
    }
}

def motionKeepOnHandler(evt)
{
    motionHandler(evt)
}

def motionHandler(evt)
{
    setCallMethod("motionHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    
    ldebug("${deviceName} <b>${deviceStatus}</b>, üí°${ isAnySwitchOn(allLights()) ? "keep on" : "turn on accordingly" }")
    state.lastmotiondt = nowDtStr()
    state.lastmotionby = deviceName    
    unschedule()

    allLights().each { grp ->
        if(grp)
        {
            ldebug("no motion, removing state ${grp.id}")
            parent?.removeLightState(grp.id)
        }
    } 

    // if(isAnySwitchOn(allLights())) //WILL THIS CAUSE TROUBLE?
    // {
    // }
}

def motionStopTurnOnHandler(evt) 
{
    motionStopHandler(evt, "motionStopTurnOnHandler")
}

def motionStopKeepOnHandler(evt) 
{
    motionStopHandler(evt, "motionStopKeepOnHandler")
}

def motionStopHandler(evt, m)
{
    setCallMethod("${m} > motionStopHandler")

    def device = evt.device // The device that triggered the event
    def deviceName = device.displayName // Get the name of the light
    def deviceStatus = evt.value // Get the value (should be "off" in this case)    
    
    //TEST IF LIGHTS ARE ON AND ALL MOTION OFF?
    if(  isAnySwitchOn(allLights()) && !isAnyMotionActive(allMotionSensors()) )
    {
        // Use a set for faster lookup
        def roomsWithMotionSensors = ["h", "lr", "mb", "k", "g", "o", "d", "test"] as Set

        if ( roomsWithMotionSensors.contains(aboutRoom) ) //ROOMS WITH MOTION SENSORS
        {
            if(state.cfgStayon > 0 && state.cfgStayon != null )
            {
                unschedule()
                runIn(state.cfgStayon, checkMotionAndTurnOff)
                state.turnofftime = addSecondsToNow(state.cfgStayon)
                
                //parent?.state.lightsStates = [] //RESET FOR TEST PURPOSE
                llog("planned off ${  getFormatted(state.turnofftime) }", "motion stop ${deviceName}, lights off in ${state.cfgStayon}s, ${  getFormatted(state.turnofftime) }")
                allLights().each { grp ->
                    if(grp)
                    {
                        ldebug("updateLightState ${grp.id} ${grp.name} ${state.turnofftime}")
                        parent?.updateLightState(grp.id, grp.name, state.turnofftime)
                    }
                }                     
            }    
            else
            {
                //loginfo("state.stayon == ${state.stayon}", "motionStopKeepOnHandler")
            }
        }
        else
        {
            ldebug("aboutRoom ${aboutRoom} no logics in motionStopHandler")
        }
    }
}

def buttonTurnOnPushedHandler(evt)
{
    setCallMethod("buttonTurnOnPushedHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    linfo("${deviceName} to <b>${deviceStatus}</b>, lights on: ${isAnySwitchOn(allLights())}")
    /*
    if(evt.value == "1")
    {
        sendLog("Lights turned on manually via button")
        state.turnedonmanually = true
    }
    */
    
}

def buttonTurnOnHeldHandler(evt)
{
    setCallMethod("buttonTurnOnHeldHandler")
    def device = evt.device
    def deviceName = device.displayName
    def deviceStatus = evt.value
    linfo("HELD, ${deviceName} to <b>${deviceStatus}</b>, lights on: ${isAnySwitchOn(allLights())}")
    /*
    if(evt.value == "1")
    {
        //state.turnedonmanually = true
    }
    */
}

//EVENTS SUBSCRIPTIONS END


//ACTIONS START
void handleLightsBasedOnConfig(states, configs, lights)
{
    setCallMethod("handleLightsBasedOnConfig")
    linfo("<code style='background-color: yellow'>${configs.base}</code>, values: ${configs.values}")
    ldebug("values: ${configs.values}")
    addConfigItem(configs.base)
    if(configs.values && configs.values.do)
    {
        if( configs.values.turnon && configs.values.forcechange )
        {
            turnOnLights(states, configs, lights, comment = "ON FORCED ${configs.values}") 
        }
        else if( configs.values.turnon && !configs.values.forcechange)
        {
            turnOnLights(states, configs, lights, comment = "ON ${configs.values}, ${states.lux} < ${states.luxThreshold}?") 
        }
        else if( !configs.values.turnon )
        {
            turnOffLights(lights)
        }
        else
        {
            ldebug("NO MATCH, ${configs.values}, ${states.lux} < ${states.luxThreshold}?")   
        }
    }
}

void turnOnLights(states, configs, lights, comment = "")
{
    setCallMethod("turnOnLights")
    state.cfgStayon = configs.values.stayon

    if(appEnabled)
    {
        //THIS IS IMPORTANT HERE. JUST BEFORE TURNING THE LIGHTS ON
        atomicState.automationLightsOn = new Date().time
        ldebug("atomicState.automationLightsOn: ${atomicState.automationLightsOn}")       

        lights.each { light ->
                if( configs.values.turnon ) //|| !isAnySwitchOn(allLights())
                {
                    //MODEJUSTCHANGED TO RESET LIGHTS TO SETTINGS
                    if(configs.values.forcechange || state.modeJustChanged)
                    {
                        state.modeJustChanged = false

                        if(isColorDevice(light))
                        {
                            def hsl = hexToHSL(configs.values.color)
                            light.setColor([hue: hsl.hue, saturation: hsl.saturation, level: configs.values.brightness])
                            linfo ("${light.displayName} ON, COLOR: ${hsl}")
                            sendLog("${light.displayName} ON, following color settings ${hsl}")
                        }
                        else
                        {
                            light.setLevel(configs.values.brightness)
                            linfo ("${light.displayName} ON, LEVEL: ${configs.values.brightness}%")
                            sendLog("${light.displayName} ON, following brightness settings ${configs.values.brightness}%")
                        }
                    }
                    else
                    {
                        linfo ("${light.displayName} ON, NO CHANGE SETTING ${light.displayName} [${configs.do}], ${comment}")
                        sendLog("${light.displayName} ON, not following settings")
                        light.on()
                    }
                }
                else if( !configs.values.turnon )
                {
                    light.off()
                    linfo("${light.displayName} OFF [${configs.turnon}], ${comment}")
                    sendLog("${light.displayName} OFF")
                }


                //logdebug "[${allStates().collect { "${it.key} : ${it.value}" }.join("] [")}]"
                //loginfo "ON ${light.displayName} [${light.collect { "${it.key} : ${it.value}" }.join("] [")}]"        

        }  
    }
    else
    {
        linfo("ON LIGHTS NOT SUCCESSFUL, APP DISABLED")
    }
}

def turnOffAllLights(force = false) 
{
    setCallMethod("turnOffAllLights")

    allLights().each { grp ->
        if(grp)
        {
            turnOffLights(grp) 
        }
    }
}

def turnOffLights(lights, force = false) 
{
    setCallMethod("turnOffLights")
    if (!appEnabled) {
        linfo("TURN OFF LIGHTS NOT SUCCESSFUL, APP DISABLED")
        return
    }

    if (!lights) {
        linfo("Turning off lights not successful, no lights provided")
        return
    }

    if (isAnySwitchOn(lights)) 
    {
        linfo("Turning off ${lights} lights")

        //if(state.turnedonmanually && state.skippedTurningOff <= 10)
        if(state.turnedonmanually && !force) //TODO state name change?
        {
            state.skippedTurningOff += 1
            //ldebug("Skip turn off, was manually turned on, skipped turning off: ${state.skippedTurningOff}")
            sendLog("${lights} not off, skipped, was manually turned on: ${state.turnedonmanually}")
        }
        else
        {
            lights.off()
            sendLog("${lights} off")
        }
    } 
    else 
    {
        linfo("Lights ${lights} already off")
    }    
    /*
    if(appEnabled)
    {
        if(lights)
        {
            if(isAnySwitchOn(lights))
            {
                linfo ("Turning off ${lights} lights")
                lights?.off()
                sendLog("turned off")
            }
            else
            {
                linfo ("Lights ${lights} already off")
            }
        }
        else
        {
            linfo ("Turning off ${lights} lights not successful")   
        }
    }
    else
    {
        linfo("TURN OFF LIGHTS NOT SUCCESSFUL, APP DISABLED")
    }
    */
}

def checkMotionAndTurnOff() 
{
    setCallMethod("checkMotionAndTurnOff")
    def currentMode = getMode()
    //ldebug(" [mb].contains(aboutRoom) : ${ ["mb"].contains(aboutRoom)}")
    //ldebug(" [SleepAll, SleepSome, SleepSomeEarlyWorkday].contains(currentMode) : ${["SleepAll", "SleepSome", "SleepSomeEarlyWorkday"].contains(currentMode)}")
    //ldebug("state.turnedonmanually : ${state.turnedonmanually } and isAnyMotionActive(motionSensorsTurnOn) : ${isAnyMotionActive(motionSensorsTurnOn)}")
    
    /*
    if( ["mb"].contains(aboutRoom)
        && ["SleepAll", "SleepSome", "SleepSomeEarlyWorkday"].contains(currentMode) 
        && !state.turnedonmanually 
        && !isAnyMotionActive(motionSensorsTurnOn)
        )    
    {
        state.callMethod = "checkMotionAndTurnOff"
        unschedule()
        linfo ("Room ${aboutRoom} and sleeping, ignore keep on and turn off lights")    
        turnOffAllLights()
    }    
    else if (  !isAnyMotionActive(allMotionSensors()) ) 
    {
        state.callMethod = "checkMotionAndTurnOff"
        unschedule()
        linfo ("No motion, turning lights off and unschedule")    
        turnOffAllLights()
    }     
    else 
    {
        state.callMethod = "checkMotionAndTurnOff"
        unschedule()
        linfo ("Still motion, turning off rescheduled with ${state.cfgStayon}s")    
        runIn(state.cfgStayon, checkMotionAndTurnOff) // Check again after 1 minute if motion persists
    }
    */
    if (  !isAnyMotionActive(allMotionSensors()) ) 
    {
        setCallMethod("checkMotionAndTurnOff")
        unschedule()
        linfo ("No motion, turning lights off and unschedule")    
        turnOffAllLights()
    }     
    else 
    {
        setCallMethod("checkMotionAndTurnOff")
        unschedule()
        linfo ("Still motion, turning off rescheduled with ${state.cfgStayon}s")    
        runIn(state.cfgStayon, checkMotionAndTurnOff) // Check again after 1 minute if motion persists
    }    
}

//ACTIONS END






//HANDLE ROOM START
def roomsHandler()
{
    setCallMethod("roomsHandler")
    state.turnedonmanually = false
    
    if(isAboutRoom("test")){ handleGeneral() }
    /*
    else if ( isAboutRoom("h") ) { handleHallway() }
    else if ( isAboutRoom("mb") ) { handleMasterBedroom() }
    else if ( isAboutRoom("lr") ) { handleLivingRoom() }
    else if ( isAboutRoom("o") ) { handleOffice() }
    else if ( isAboutRoom("g,k,d") ) { handleSimpleMotion() }
    */
    else if ( isAboutRoom("h,mb,lr,k,o,g,k,d") ) { handleGeneral() }
    else if ( isAboutRoom("w,s") ) { handleSimpleDoor() }    
}

void settingsHandler(states)
{
    setCallMethod("settingsHandler")
    lightGroupArray().each { grp ->
        if(grp)
        {
            ldebug("dynamic go through ${states.mode}, ${grp.id} and ${states.isRoomState}")
            def cfg = getConfig(states.mode, grp.id, states.isRoomState)    
            handleLightsBasedOnConfig(states, cfg, grp.devices)                    
        }
    }   
}

void handleGeneral(manual = "")
{
    setCallMethod("handleGeneral")
    def states = allStates()

    if(states.isvalidmode)
    {
        if(false)
        {
        
        }
        /*
        else if(manual == "pushsingle")
        {
            def cfg = getConfig(states.mode, "mainlights", "buttonpushed")    
            handleLightsBasedOnConfig(states, cfg, mainlights)                        
        }
        else if(manual == "pushdouble")
        {
            def cfg = getConfig(states.mode, "mainlights", "buttondoublepushed")    
            handleLightsBasedOnConfig(states, cfg, mainlights)                        
        }        
        else if(manual == "pushheld")
        {
        } 
        */   
        else
        {
            settingsHandler(states)    
        }
    }    
}

void handleSimpleMotion(manual = "") //LOW LIGHT AND MOTION ON OR OFF
{
    setCallMethod("handleSimpleMotion")
    def currentMode = getMode()
    def states = allStates()
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        } 
        else
        {
            settingsHandler(states)         
        }           
    }
}

void handleSimpleDoor(manual = "") //CONTACT ON OR OFF
{
    setCallMethod("handleSimpleDoor")
    def currentMode = getMode()
    def states = allStates()
   
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else
        {
            if(isAnyContactOpen(roomDoors))
            {
                def cfg = getConfig(currentMode, "mainlights", "roomdoorsopen")
                handleLightsBasedOnConfig(states, cfg, mainlights)
                runIn(state.cfgStayon, turnOffAllLights)
            }
            else
            {
                mainlights.off()
                unschedule()
            }
        }    
    
    }
}
//HANDLE ROOM END






void appButtonHandler(String buttonName) 
{
    setCallMethod("appButtonHandler")
    ldebug( "Button pressed: $buttonName")
    if (buttonName == "Save") 
    {
        ldebug( "Saved button logic executed")
    }
    
    if (buttonName == "AllLightsOff") 
    {
        ldebug( "Off lights off button logic executed")
        turnOffAllLights(true)
    }    
    
    if (buttonName == "AllMotionInActive") 
    {
        ldebug( "All motion inactive button logic executed")
        setMotionInactive() 
        // Add your save logic here
    }   

    if (buttonName == "copyButton") 
    {
        copyConfigurations() 
    }

    if (buttonName == "deleteButton") 
    {
        deleteConfigurations() 
    }         
}


def copyConfigurations() 
{
    setCallMethod("copyConfigurations")
    if (sourceMode != targetMode) 
    {
            lightGroupArray().each { grp -> 
                if(grp.devices)
                {
                    stateGroupArray().each { s ->
                        def nmsSource = getConfig(sourceMode, grp.id, s.id)
                        def nmsTarget = getConfig(targetMode, grp.id, s.id)
                        ldebug("source: ${nmsSource.base} - > target: ${nmsTarget.base}")

                        app.updateSetting(nmsTarget.do, [value: nmsSource.values.do, type: "bool"])
                        app.updateSetting(nmsTarget.turnon, [value: nmsSource.values.turnon, type: "bool"])
                        app.updateSetting(nmsTarget.forcechange, [value: nmsSource.values.forcechange, type: "bool"])
                        app.updateSetting(nmsTarget.brightness, [value: nmsSource.values.brightness, type: "number"])
                        app.updateSetting(nmsTarget.stayon, [value: nmsSource.values.stayon, type: "bool"])
                        app.updateSetting(nmsTarget.color, [value: nmsSource.values.color, type: "color"])
                    }
                }
            }
        linfo("Configurations from mode '${sourceMode}' copied to mode '${targetMode}'.")
    } else {
        lwarn("Source '${sourceMode}' and Target '${targetMode}' mode are the same, nothing to copy.")
    }
}

def deleteConfigurations() 
{
    setCallMethod("deleteConfigurations")
    if (sourceMode != targetMode) 
    {
            lightGroupArray().each { grp -> 
                if(grp.devices)
                {
                    stateGroupArray().each { s ->
                        def nmsTarget = getConfig(targetMode, grp.id, s.id)
                        ldebug("removing: ${nmsTarget.base}")
                        app.removeSetting(nmsTarget.do)
                        app.removeSetting(nmsTarget.turnon)
                        app.removeSetting(nmsTarget.forcechange)
                        app.removeSetting(nmsTarget.brightness)
                        app.removeSetting(nmsTarget.stayon)
                        app.removeSetting(nmsTarget.color)
                    }
                }
            }
        linfo("Configurations from target mode '${targetMode}' deleted.")
    } 
}

def isAboutRoom(commadelimitedInput)
{
    return commadelimitedInput.split(',').contains(aboutRoom)
}

def isAboutMode(commadelimitedInput)
{
    return commadelimitedInput.split(',').contains(getMode())
}

def lightGroupArray()
{
    return [
    	[id: "mainlights", description: "Main lights", devices: mainlights],
    	[id: "sidelights", description: "Side lights", devices: sidelights]
	]
} 

def allLights() 
{
    def mergedDevices = []
    lightGroupArray().each { grp ->
        if (grp.devices instanceof List) 
        {
            mergedDevices.addAll(grp.devices)
        }
    }
    //allLights = allLights.unique() // Remove duplicates
    return mergedDevices.unique()
}   

def allMotionSensors()
{
    def mergedDevices = []
    if(motionSensorsTurnOn)
    {
        mergedDevices.addAll(motionSensorsTurnOn)
    }
    if(motionSensorsKeepOn)
    {
        mergedDevices.addAll(motionSensorsKeepOn)
    }   

    //allLights = allLights.unique() // Remove duplicates
    return mergedDevices.unique()

	//return (motionSensorsTurnOn ?? []) + (motionSensorsKeepOn ?? [])
}

def stateGroupArray()
{
    return [
        [id: "dark", description: "üö∂dark", devices: [isDarkSwitch,luxSensor], matchnow: isSwitchOn(isDarkSwitch) || luxSensor?.currentIlluminance < luxThreshold],
        [id: "roomdoorsopen", description: "üö™room", devices: roomDoors, matchnow: isAnyContactOpen(roomDoors)],
        [id: "housedoorsopen", description: "üö™house", devices: houseDoors, matchnow: isAnyContactOpen(houseDoors)],

        //["no", "motion != dark"],
        //["lightsmanuallyon", "when lights manually on"],
        //["buttonpushed", "when button pushed"],
        //["buttondoublepushed", "when button double pushed"],
        //["istvon", "when tv on"],
    ]
} 

def getMode()
{
    def chosenMode = location.mode 
    
    if("${mainlights}".contains("TEST"))
    {
        //chosenMode = "SleepSome" 
        chosenMode = "SleepAll" 
    }
    return chosenMode
}


def getConfig(modename, lightnameId, statenameId)
{
    setCallMethod("getConfig")
    def result = []

    if ([lightnameId, statenameId, modename].every { it != null }) 
    {
        def isValidLight = lightGroupArray().any { it.id == lightnameId } //F.E. mainlights
        def isValidState = stateGroupArray().any { it.id == statenameId } //F.E. dark
        if(isValidLight && isValidState)
        {
            def l = lightGroupArray().find { it.id == lightnameId }.description
            def s = stateGroupArray().find { it.id == statenameId }.description
            def stateDescription = "${s}"
            def base = "${modename}_${lightnameId}_${statenameId}"
            
            //def titleGrpState = "<table class='noborder'><tr><td>üß©</td><td>${modename.toUpperCase()}</td></tr><tr><td>üí°</td><td>${l.toLowerCase()}</td></tr><tr><td>‚öôÔ∏è</td><td>${s.toLowerCase()}</td></tr></table>"
            def titleGrpState = "‚öôÔ∏è${s?.toLowerCase()}"
            result = [
                statedescription: stateDescription,
                title: titleGrpState,
                base: "${base}",
                do: "${base}_do",
                turnon: "${base}_turn_on",
                forcechange: "${base}_forcechange",
                brightness: "${base}_brightness",
                color: "${base}_color",
                stayon: "${base}_stayon",
                lightname: lightname,
                values: [
                    do: settings["${base}_do"],
                    turnon: settings["${base}_turn_on"],
                    forcechange: settings["${base}_forcechange"],
                    brightness: settings["${base}_brightness"],
                    color: settings["${base}_color"],
                    stayon: settings["${base}_stayon"],
                ]
                //def result = settings[${turnon}]
            ]
        }
        else
        {
            ldebug ("‚ùåsettings not found, modename: ${modename}, lightname : ${lightname} : ${isValidLight}, statename: ${statename} : ${isValidState}")
            result = [
                base: "no_configuration"
            ]            
        }
    }
    else
    {
        ldebug ("‚ùåparameter empty, not settings, modename: ${modename}, lightname : ${lightname} : ${isValidLight}, statename: ${statename} : ${isValidState}")
        result = [
            base: "invalid_amount_parameters"
        ]
    }    
    return result
}

def allStates()
{
    setCallMethod("allStates")
    def currentmode = getMode()
    def includedModes = parent?.includedModes() ?: []
    def isConsideredDark = isSwitchOn(isDarkSwitch) || luxSensor?.currentIlluminance < luxThreshold

    def determineRoomState = ""
    if(isConsideredDark)
    {
        determineRoomState =  stateGroupArray()[0].id //"roomdoorsopen"

        if(isAnyContactOpen(roomDoors))
        {
            determineRoomState =  stateGroupArray()[1].id //"roomdoorsopen"
        }
        if(isAnyContactOpen(houseDoors))
        {
            determineRoomState =  stateGroupArray()[2].id //"housedoorsopen"
        }
    }
    ldebug("determineRoomState: ${determineRoomState}")

    return [mode:currentmode,
            isvalidmode: (includedModes && includedModes.contains(currentmode)),  
            isconsidereddark: isConsideredDark,
            isDarkOrNoCfg : isConsideredDark ? "dark" : "",
            isAnyMotion: isAnyMotionActive(allMotionSensors()),
            isAnyLightOn : isAnySwitchOn(allLights()),
            isAnyLightOnMain : isAnySwitchOn(mainlights),
            isAnyLightOnSide : isAnySwitchOn(sidelights),
            /*
            isAnyLightOnExtra1 : isAnySwitchOn(extralights1),
            isAnyLightOnExtra2 : isAnySwitchOn(extralights2),
			*/
            isDoorOpenRoom:isAnyContactOpen(roomDoors),
            isDoorOpenHouse:isAnyContactOpen(houseDoors),
            isRoomState: determineRoomState,
            //socketPlugPower:socketPlug?.currentValue("power"),
            //isSocketPlugUsingPower:socketPlug?.currentValue("power") > powerThreshold,
            isWeekDay: ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
            //isEarlyWorkTime: isTimeBetween("04:20", "05:30") && ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
            //isEarlyWorkTime: isTimeBetween("13:05", "13:07") && ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
        ]
}

//SMALL FUNCTIONS
def isAnySwitchOn(devices)
{
    //if(devices == null) return false

    def anyOn = devices.find { it?.currentValue("switch") == "on" }
    return anyOn != null
}

def isAnyMotionActive(devices)
{
   	def anyActive =  devices.find { sensor ->
        isMotionActive(sensor)
    }
    //ldebug("any motion sensors active?: ${devices}, result : <b>${anyActive}</b>")
    return anyActive != null
}

def isAnyContactOpen(devices)
{
    //if(devices == null) return false

    def anyOpen = devices.find { isContactOpen(it) }
    return anyOpen != null
}

def isSwitchOn(device) 
{
    return device?.currentValue("switch") == "on"
}

def isContactOpen(device) 
{
    return device?.currentValue("contact") == "open"
}

def isMotionActive(device) 
{
    //setCallMethod("isMotionActive")
    //ldebug("motion sensor ${device} is active? <b>${device.currentMotion == "active"}</b>")
    return device.currentMotion == "active"
}

def isVirtual(device) 
{
    return device?.getTypeName()?.toLowerCase()?.contains("virtual") ?: false
}

def isColorDevice(device) 
{
    return device.hasCapability("ColorControl")
}

def getLatestStatesSortedByTime(devices, attribute) {
    def latestStates = devices.collect { device ->
        def latestState = device.latestState(attribute)
        [
            device: device?.displayName, 
            value: latestState?.value, 
            time: latestState?.date
        ]
    }.sort { it.time } // Sort by time (descending order)
	
    return latestStates
}

def isTimeBetween(timeStart, timeEnd) 
{
    setCallMethod("isTimeBetween")
    def now = new Date()
    def start = parseTime(timeStart)
    def end = parseTime(timeEnd)

    // Adjust end time if it is before the start time (for times that cross midnight)
    if (end < start) {
        end += 24 * 60 * 60 * 1000 // add a day in milliseconds
    }
   
    def result = now >= start && now <= end
    ldebug("isTimeBetween: ${timeStart} - ${timeEnd} = ${start} - ${end} = ${result}")
    return result
}

def parseTime(timeStr) 
{
    setCallMethod("parseTime")
    def timeParts = timeStr.split(':')
    def now = new Date()
    def result = new Date(now.year, now.month, now.date, timeParts[0].toInteger(), timeParts[1].toInteger())
    ldebug("parseTime: ${timeStr} = ${result}")
    return result
}

def hexToHSL(hex) 
{
    setCallMethod("hexToHSL")

    // Remove the # symbol if present
    hex = hex.replace("#", "")

    // Convert hex to RGB
    int r = Integer.valueOf(hex.substring(0, 2), 16)
    int g = Integer.valueOf(hex.substring(2, 4), 16)
    int b = Integer.valueOf(hex.substring(4, 6), 16)

    float rPct = r / 255.0
    float gPct = g / 255.0
    float bPct = b / 255.0

    float max = Math.max(rPct, Math.max(gPct, bPct))
    float min = Math.min(rPct, Math.min(gPct, bPct))

    float h = 0
    float s = 0
    float l = (max + min) / 2

    if (max != min) {
        float d = max - min
        s = (l > 0.5) ? d / (2.0 - max - min) : d / (max + min)

        if (max == rPct) {
            h = (gPct - bPct) / d + (gPct < bPct ? 6 : 0)
        } else if (max == gPct) {
            h = (bPct - rPct) / d + 2
        } else if (max == bPct) {
            h = (rPct - gPct) / d + 4
        }

        h /= 6
    }

    h = Math.round(h * 100)
    s = Math.round(s * 100)
    l = Math.round(l * 100)

    ldebug("hex: ${hex} = HSL: ${h}, ${s}, ${l}")
    return [hue: h, saturation: s, level: l]
}

def isNull(value) {
    return value == null
}

def isString(value) {
    return value != null && value instanceof String
}

def addSecondsToNow(seconds, format = "yyyy-MM-dd'T'HH:mm:ss.SSS") 
{
    def now = new Date()
    def newTime = new Date(now.time + (seconds * 1000))
    return newTime.format(format)
}



def nowDt()
{
    //return new Date()
    return new Date().time 
}

def nowDtStr(format = "yyyy-MM-dd'T'HH:mm:ss.SSS")
{
    return new Date().format(format)
}


def parseToDate(dateString, format = "yyyy-MM-dd'T'HH:mm:ss.SSS") 
{
    //setCallMethod("parseToDate")
    //ldebug("parseToDate: ${dateString}")
    return Date.parse(format, dateString)
}

def calculateSecondsBetweenDates(Long startDate, Long endDate) 
{
    return calculateMsBetweenDates(startDate, endDate) / 1000
}

def calculateMsBetweenDates(Long startDate, Long endDate) 
{
    //setCallMethod("calculateMsBetweenDates")
    def differenceInMs = endDate - startDate
    //ldebug("startDate: ${startDate}, endDate: ${endDate}, diff: ${differenceInMillis}")
    return differenceInMs
}




//PARENT WRAPPERS
def getFormatted(input, format = "HH:mm:ss.SSS")
{
    return parent?.getFormatted(input, format)
}

def humanizeDatetime(inputTime) 
{
    return parent?.humanizeDatetime(inputTime) 
}

String boolToOnOff(value = false) 
{
    if(value) return value ? "on" : "off"
    return "off"
}
String boolToYesNo(value = false) 
{
    if(value) return value ? "yes" : "no"
    return "no"
}
String boolToIcon(value = false) 
{
    if(value) return value ? "&#10003;" : "&#10007;"
    return "&#10007;"
}
String boolToArrowIcon(value = false) 
{
    if(value) return value ? "&#10140;" : ""
    return ""
}

void addConfigItem(String configName) 
{
    // Initialize the state list if it doesn't exist
    state.usedConfigHistory = state.usedConfigHistory ?: []
    
    // Add the new item to the top of the list with a timestamp
    def newItem = [name: configName, time: nowDtStr()]
    state.usedConfigHistory.add(0, newItem)
    
    // Ensure the list only keeps the last 5 items
    if (state.usedConfigHistory.size() > 5) {
        state.usedConfigHistory = state.usedConfigHistory.take(5)
    }
}


def setAppname(String str = null)
{
    state.appName = str
}
def getAppname()
{
    return state.appName
}
def setCallMethod(String str = null)
{
    state.callMethod = str
}
def getCallMethod()
{
    return state.callMethod
}

def llog(infomessage, debugmessage)
{
    if(parent?.txtEnable)
    {
        linfo(infomessage)
    }
    if(parent?.logEnable)
    {
        ldebug(debugmessage)
    }
}
def ldebug(message)
{
    parent?.l(message, getAppname(), getCallMethod(), "debug")
}
def lwarn(message)
{
	parent?.l(message, getAppname(), getCallMethod(), "warn")
}
def lerror(message)
{
	parent?.l(message, getAppname(), getCallMethod(), "error")
}
def linfo(message)
{
	parent?.l(message, getAppname(), getCallMethod(), "info")
}
void sendLog(String message)
{
    parent?.sendMessage( parent?.sendMessageLog, message, getAppname(), getCallMethod() )
}
void sendImportant(String message)
{
    parent?.sendMessage( parent?.sendMessageImportant, message, getAppname(), getCallMethod() )
}
