import groovy.json.JsonOutput
import groovy.time.TimeCategory
import java.text.SimpleDateFormat

definition(
    name: "ðŸš€Lights automation configurable v3",
    namespace: "Roberto Lee",
    author: "RL",
    description: "Turn lights on based on motion, lux, mode, and apply mode-specific brightness and color when lights are off. Doors status applies",
    category: "Convenience",
    iconUrl: "",
    iconX2Url: ""
)

preferences {
    def states = allStates()
    section("INFO") {
        def generalinfo = "";
        generalinfo += "Mode is now <b>${states.mode}</b>. "
        generalinfo += "Triggered on since: \"<b>${state.lasttrigger}</b>\" on  <b>${state.lasttriggertime}</b>\n"
        generalinfo += "Last Automation since: \"<b>${state.lastautomationtime}</b>\". Turned on manually: ${state.turnedonmanually}. Enabled: ${manuallyOverrideEnable}\n"
        
        generalinfo += "Last motion since: \"<b>${state.lastmotiontime}</b>\"\n"
        generalinfo += "Motionless since: \"<b>${state.motionlesstime}</b>\"\n"
        generalinfo += "Turning off is: \"<b>${state.turnofftime}</b>\" (${state.stayon}s)\n"
        generalinfo += "Keep on, motion detected, unscheduled: \"<b>${state.motiondetectedkeeponunscheduletime}</b>\" (${state.stayon}s)\n"
        generalinfo += "Keep on, motion stopped, unscheduled: \"<b>${state.motionstoppedkeeponunscheduletime}</b>\" (${state.stayon}s)\n"
        
        
        
        paragraph "${generalinfo}"
        
        def darkvars = "";
        darkvars += "Lux last measured: ${state.lastmeasuredlux}, now: <b>${states.lux}</b> and threshold: <b>${states.luxThreshold}</b> and IsDark switch is <b>${states.darkon}</b>\n"
        darkvars += "Is dark? <b>${states.darkon || (state.lux < states.luxThreshold)}</b>"
        paragraph "${darkvars}"
        
        def motions = "";
        if(motionSensorsKeepOn)
        {
            motionSensorsKeepOn.each { sensor ->
                 //motions += "Motion started ${sensor}: <b>${sensor.latestState("motion")?.date.format('yyyy-MM-dd, HH:mm:ss')}</b>\n"
                motions += "<a target =\"_blank\" href=\"/device/edit/${sensor.id}\">${sensor}</a>: ${sensor.currentValue("motion")}, latest state: ${sensor.latestState("motion")?.date.format('yyyy-MM-dd, HH:mm:ss')} = ${sensor.latestState("motion")?.value}\n"
            }
            paragraph "${motions}"
            
        }
        
        // Convert object to JSON
        //def jsonOutput = JsonOutput.prettyPrint(JsonOutput.toJson(motionSensorsKeepOn))
        //paragraph "<br/>All sensor states: <i>${JsonOutput.prettyPrint(jsonOutput)}</i>"
        
        
        //def anyOn = devices.find { it.currentValue("switch") == "on" }
        def lightsstate = ""
        if(mainlights)
        {
            mainlights.each { light ->
                lightsstate += "<a target =\"_blank\" href=\"/device/edit/${light.id}\">${light}</a>: ${light.currentValue("switch")}, latest state: ${light.latestState("switch")?.date.format('yyyy-MM-dd, HH:mm:ss')} = ${light.latestState("switch")?.value}\n"
            }  
        }
        if(sidelights)
        {
            sidelights.each { light ->
                //lightsstate += "${light}: ${light.currentValue("switch")}, ${light.latestState("switch")?.date.format('yyyy-MM-dd, HH:mm:ss')} = ${light.latestState("switch")?.value}\n"
                lightsstate += "<a target =\"_blank\" href=\"/device/edit/${light.id}\">${light}</a>: ${light.currentValue("switch")}, latest state: ${light.latestState("switch")?.date.format('yyyy-MM-dd, HH:mm:ss')} = ${light.latestState("switch")?.value}\n"
            }  
        }      
        paragraph "${lightsstate}"
        
        paragraph "<br/>All states: <i>${states}</i>"
        
        
        //
    }      
    section("Settings")
    {
        input "aboutRoom", "enum", title: "Select room", options: ["h", "lr", "mb", "g", "k", "s", "w", "o"], required: true
        //input name: "logPrefix", type: "text", title: "Prefix log", required: true, defaultValue: "âš™ï¸"
        input "logEnable", "bool", title: "Enable extensive logging", required: true
        input "txtEnable", "bool", title: "Enable description text logging.", defaultValue: true, required: true
    }
    section("Settings enable")
    {
        input "manuallyOverrideEnable", "bool", title: "Allow manually override. After turning on lights. No automation active until lights are turned off.", defaultValue: true, required: true
    }    
    section("Select devices") {
        lightGroupArray().each { grp ->
            def grpName = grp[0]
            def gprDescription = grp[1].toLowerCase()
            input "${grpName}", "capability.switchLevel", title: "Select ${gprDescription}", required: false, multiple: true
        }
        input "motionSensorsTurnOn", "capability.motionSensor", title: "Select motion sensors to turn on light(s)", required: false, multiple: true
        input "motionSensorsKeepOn", "capability.motionSensor", title: "Select motion sensors to keep on light(s), <b>motion: ${states.isMotion}</b>", required: false, multiple: true
        input "luxSensor", "capability.illuminanceMeasurement", title: "Select lux sensor, <b>lux measured: ${states.lux}</b>", required: false
        input "isDarkSwitch", "capability.switch", title: "IsDark Switch, is <b>on: ${states.darkon}</b>", required: false

        input "roomDoors", "capability.contactSensor", title: "Room doors, is <b>open: ${states.isOpenRoomDoor}</b>", required: false, multiple: true
        input "houseDoors", "capability.contactSensor", title: "House doors, is <b>open: ${states.isOpenHouseDoor}</b>", required: false, multiple: true
        input "socketPlug", "capability.powerMeter", title: "Select socket plug, power in watts <b>measured: ${states.socketPlugPower}, is using power: ${states.isSocketPlugUsingPower}</b>", required: false
        input "turnOnButtons", "capability.pushableButton", title: "Which buttons turnon?", required: false, multiple: true
    }
    section("Configs") {
        input "luxThreshold", "number", title: "Lux Threshold for turning on the lights, <b>lux measured: ${states.lux} , islow: ${states.luxlow}</b> ", required: false, defaultValue: 50
        input "powerThreshold", "number", title: "Power threshold for it to be considered on (watts), <b>measured: ${states.socketPlugPower}, is using power: ${states.isSocketPlugUsingPower}</b>", required: false, defaultValue: 55
    }
    section("Select Mode(s) to Activate Turning On Light") {
        input "includedModes", "mode", title: "Modes to Include", multiple: true, required: false
    }
    includedModes.each { mode ->
        lightGroupArray().each { grp ->  // Loop through each row
            def grpName = grp[0]
            logdebug "${grpName}"
            stateGroupArray().each { state ->
                def stateName = state[0]
                def nms = getConfig(mode, grpName, stateName)
                section("${nms.title} <code style='background-color: yellow;'>${nms.base}</code>", hideable: true, hidden: !nms.values.do) {
                    input "${nms.do}", "bool", title: "${nms.statedescription} DO? Otherwise skip actions <code style='background-color: yellow'>${nms.do}</code>", required: true, defaultValue: false
                    input "${nms.turnon}", "bool", title: "${nms.statedescription} turn light on? <code style='background-color: yellow'>${nms.turnon}</code>", required: true, defaultValue: false
                    //if(nms.values.turnon)
                    //{
                        input "${nms.forcechange}", "bool", title: "${nms.statedescription} force change even if lights on? <code style='background-color: yellow'>${nms.forcechange}</code>", required: true, defaultValue: false
                        input "${nms.stayon}", "number", title: "${nms.statedescription} stayon in seconds <code style='background-color: yellow'>${nms.stayon}</code>", required: true, defaultValue: 30
                        input "${nms.brightness}", "number", title: "${nms.statedescription} brightness (0-100)<code style='background-color: yellow'>${nms.brightness}</code>", required: true, defaultValue: 88
                        input "${nms.color}", "color", title: "${nms.statedescription} color <code style='background-color: yellow'>${nms.color}</code>", required: false, defaultValue: "#ffffff"
                    //}
                }
            }
        }
    }
}

def getMode()
{
    def chosenMode = location.mode 
    
    if("${mainlights}".contains("TEST"))
    {
        chosenMode = "SleepSome" 
    }
    
    return chosenMode
}

def lightGroupArray()
{
    return [
        ["mainlights", "Main lights"],
        ["sidelights", "Side lights"],
    ]
} 
def stateGroupArray(){
    return [
        ["no", "motion not dark"],
        ["dark", "motion dark"],
        ["roomdoorsopen", "when room door open"],
        ["housedoorsopen", "when house door open"],
        ["lightsmanuallyon", "when lights manually on"],
        
        //["buttonpushed", "when button pushed"],
        //["buttondoublepushed", "when button double pushed"],
        //["istvon", "when tv on"],
    ]
} 

def logdebug(message, methodName ="") {
    if (logEnable)
    {
        if(methodName != "")
        {
            state.logPostfix = methodName
        }
        log.debug "[âš™ï¸${state.logPrefix}] ${message} âžœ${state.logPostfix}"
    }
}

def loginfo(message, methodName ="") {
    if(txtEnable)
    {
        if(methodName != "")
        {
            state.logPostfix = methodName
        }
        log.info "[âš™ï¸${state.logPrefix}] ${message} âžœ${state.logPostfix}"
    }
}

def installed() {
    //logdebug "Installed with settings: ${settings}"
    initialize()
}

def updated() {
    //logdebug "Updated with settings: ${settings}"
    unsubscribe()
    initialize()
}

def initialize() {
    def callMethod = "initialize"
    state.logPrefix = "${settings.aboutRoom}"
    logdebug("initializing...", callMethod)

    subscribe(location, "mode", modeChangedHandler)
    subscribe(isDarkSwitch, "switch.on", switchesHandler)
    subscribe(isDarkSwitch, "switch.off", switchesHandler)
    
    if(mainlights)
    {
        subscribe(mainlights, "switch", lightSwitchesHandler)
        subscribe(mainlights, "switch.on", lightSwitchedOnHandler)
        subscribe(mainlights, "switch.off", lightSwitchedOffHandler)
    }
    if(sidelights)
    {
        subscribe(sidelights, "switch.on", lightSwitchedOnHandler)
        subscribe(sidelights, "switch.off", lightSwitchedOffHandler)
    }
    if(luxSensor)
    {
        subscribe(luxSensor, "illuminance", luxChangedHandler)
    }
    if(motionSensorsTurnOn)
    {
        motionSensorsTurnOn.each { sensor ->
            subscribe(sensor, "motion.active", motionDetectedTurnOnHandler)
            subscribe(sensor, "motion.inactive", motionStoppedTurnOnHandler)
        }
    }
    if(motionSensorsKeepOn)
    {
        motionSensorsKeepOn.each { sensor ->
            subscribe(sensor, "motion.active", motionDetectedKeepOnHandler)
            subscribe(sensor, "motion.inactive", motionStoppedKeepOnHandler)
        }
    }
    if(roomDoors)
    {
        subscribe(roomDoors, "contact", roomDoorsHandler)
    }
    if(houseDoors)
    {
        subscribe(houseDoors, "contact.open", houseDoorsHandler)
    }
    if(socketPlug)
    {
        subscribe(socketPlug, "power", powerChangedHandler)
    }
    if(turnOnButtons)
    {
        subscribe(turnOnButtons, "pushed", buttonTurnOnPushedHandler)
        subscribe(turnOnButtons, "doubleTapped", buttonTurnOnDoubleTappedHandler)
        subscribe(turnOnButtons, "held", buttonTurnOnHeldHandler)
    }
    logdebug ("subscriptions complete.", callMethod)

    unschedule(turnOffIfInactive)
    
    state.turnedonmanually = false
}
//DEBUG
void spitOut(states, configs)
{
    def callMethod = "spitOut"
    logdebug(lightGroupArray()[0][0])
    //config = getConfig("Away", "mainlights", "no")
    logdebug("config ${configs}", callMethod)
    logdebug("isvalidmode ${configs.isvalidmode}", callMethod)
    logdebug("state ${states}", callMethod)
    logdebug("mode ${states.mode}", callMethod)
    logdebug("color ${configs.values.color}", callMethod)
    logdebug("room ${aboutRoom}", callMethod)
    //["SleepAll", "SleepSome"].contains(getMode())    
    ["g", "k"].contains(aboutRoom)    
}

//LOGICS
void handleSimpleMotion(manual = "") //LOW LIGHT AND MOTION ON OR OFF
{
    def callMethod = "handleSimpleMotion"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod)   
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        } 
        else
        {
            sidelights?.off()
            if(states.isAnyLightOnMain)
            {
                logdebug("skip main lights already on", callMethod)
            }            
            else
            {
                def cfg = getConfig(currentMode, "mainlights", states.isDarkOrNoCfg)    
                handleLightsBasedOnConfig(states, cfg, mainlights)
            }            
        }           
    }
}

void handleSimpleDoor(manual = "") //CONTACT ON OR OFF
{
    def callMethod = "handleSimpleDoor"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod)   
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else if(states.isOpenRoomDoor)
        {
            def cfg = getConfig(currentMode, "mainlights", "roomdoorsopen")
            handleLightsBasedOnConfig(states, cfg, mainlights)
            
            runIn(state.stayon, turnOffLights)
        }    
        else if(!states.isOpenRoomDoor)
        {
            mainlights.off()
            unschedule(turnOffLights)
        }         
    }
}

void handleOffice()
{
    def callMethod = "handleOffice"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod)  
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else if(states.isAnyLightOnMain)
        {
            def cfg = getConfig(currentMode, "mainlights", "lightsmanuallyon")
            handleLightsBasedOnConfig(states, cfg, mainlights)
            
            runIn(state.stayon, turnOffLights)
        }    
        else if(!states.isAnyLightOnMain)
        {
            mainlights.off()
            unschedule(turnOffLights)
        }         
    }    
}

void handleKidsRoom(manual = "") //LEX
{
    def callMethod = "handleKidsRoom"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod)   
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else if(states.isOpenRoomDoor)
        {
            def cfg = getConfig(currentMode, "mainlights", "roomdoorsopen")
            handleLightsBasedOnConfig(states, cfg, mainlights)
        }    
        else if(!states.isOpenRoomDoor)
        {
            mainlights.off()
        }         
    }
}

void handleMasterBedroom(manual = "") 
{
    def callMethod = "handleMasterBedroom"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod) 
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else if(manual == "pushsingle")
        {
            handleLightsBasedOnConfig(states, getConfig("Normal", "mainlights", "buttonpushed"), mainlights)                        
            handleLightsBasedOnConfig(states, getConfig("Normal", "sidelights", "buttonpushed"), sidelights)                 
        }
        else if(manual == "pushdouble")
        {
            handleLightsBasedOnConfig(states, getConfig("Normal", "mainlights", "buttondoublepushed"), mainlights)                        
            handleLightsBasedOnConfig(states, getConfig("Normal", "sidelights", "buttondoublepushed"), sidelights)                        
        }        
        else if(manual == "pushheld")
        {
        }              
        else if( ["SleepAll", "SleepSome", "SleepSomeEarlyWorkday"].contains(currentMode) )
        {
            def cfg = getConfig(currentMode, "sidelights", "dark")
            handleLightsBasedOnConfig(states, cfg, sidelights)
        }  
        else if( ["Normal", "NormalWorking"].contains(currentMode) )
        {
            sidelights?.off()
            def cfg = getConfig(currentMode, "mainlights", states.isDarkOrNoCfg)
            handleLightsBasedOnConfig(states, cfg, mainlights)
        }         
        else
        {
            
        }         
    }
}

void handleLivingRoom(manual = "")
{
    def callMethod = "handleLivingRoom"
    def currentMode = getMode()
    def states = allStates()
    logdebug("states ${states}", callMethod)   
    
    if(states.isvalidmode)
    {
        if(false)
        {
        
        }   
        else if( ["SleepSome", "SleepSomeEarlyWorkday"].contains(currentMode) && states.isSocketPlugUsingPower )
        {
            handleLightsBasedOnConfig(states, getConfig(currentMode, "mainlights", "istvon") , mainlights)
            handleLightsBasedOnConfig(states, getConfig(currentMode, "sidelights", "istvon") , sidelights)
        }  
        else if( ["SleepSome","SleepSomeEarlyWorkday"].contains(currentMode) && !states.isSocketPlugUsingPower )
        {
            handleLightsBasedOnConfig( states, getConfig(currentMode, "mainlights", states.isDarkOrNoCfg) , mainlights)
            handleLightsBasedOnConfig( states, getConfig(currentMode, "sidelights", states.isDarkOrNoCfg) , sidelights)
        }  
        else if( ["Normal", "NormalWorking"].contains(currentMode) )
        {
            sidelights?.off()
            handleLightsBasedOnConfig(states, getConfig(currentMode, "mainlights", states.isDarkOrNoCfg) , mainlights)
        }         
        else
        {
            
        }         
    }
}

void handleHallway(manual = "")
{
    def callMethod = "handleHallway"
    def currentMode = getMode()
    def states = allStates()
    //logdebug("states ${states}", "handleHallway")

    if(states.isvalidmode)
    {
        if(false)
        {
        
        }
        else if(manual == "pushsingle")
        {
            def cfg = getConfig(currentMode, "mainlights", "buttonpushed")    
            handleLightsBasedOnConfig(states, cfg, mainlights)                        
        }
        else if(manual == "pushdouble")
        {
            def cfg = getConfig(currentMode, "mainlights", "buttondoublepushed")    
            handleLightsBasedOnConfig(states, cfg, mainlights)                        
        }        
        else if(manual == "pushheld")
        {
        }                
        //else if(states.mode == "SleepSome" && states.isOpenHouseDoor && states.isEarlyWorkTime)
        //(states.mode == "SleepSome" || states.mode == "SleepSomeEarlyWorkday")
        else if(states.mode == "SleepSomeEarlyWorkday" && states.isOpenHouseDoor)
        {
            turnOffLights()
        } 
        else if(states.isOpenHouseDoor && states.mode != "SleepSomeEarlyWorkday")
        {
            sidelights.off()
            
            def cfg = getConfig(currentMode, "mainlights", "housedoorsopen")    
            handleLightsBasedOnConfig(states, cfg, mainlights)            
        }         
        else if(states.mode == "SleepAll" && states.isOpenRoomDoor)
        {
            mainlights.off()

            def cfg = getConfig(currentMode, "sidelights", "roomdoorsopen")
            handleLightsBasedOnConfig(states, cfg, sidelights)
        }  
        else
        {
            sidelights.off()
            if(states.isAnyLightOnMain)
            {
                logdebug("skip main lights already on", callMethod)
            }            
            else
            {
                def cfg = getConfig(currentMode, "mainlights", states.isDarkOrNoCfg)    
                handleLightsBasedOnConfig(states, cfg, mainlights)
            }            
        }    
    }    
}

void handleLightsBasedOnConfig(states, configs, lights)
{
    def callMethod = "handleLightsBasedOnConfig"
    logdebug("${states.mode} âžœ <code style='background-color: yellow;'>${configs.base}</code>", callMethod)
    if(configs.values.do)
    {
        if( configs.values.turnon && configs.values.forcechange )
        {
            turnOnLights(states, configs, lights, comment = "ON FORCED ${configs.values}") 
        }
        else if( configs.values.turnon && !configs.values.forcechange && !isAnySwitchOn(lights) )
        {
            turnOnLights(states, configs, lights, comment = "ON ${configs.values}, ${states.lux} < ${states.luxThreshold}?") 
        }
        else if( !configs.values.turnon )
        {
            turnOffGrpLights(lights)
        }
        else
        {
            logdebug("NO MATCH, ${configs.values}, ${states.lux} < ${states.luxThreshold}?",callMethod)   
        }
    }
}


//EVENTS HANDLERS
def motionDetectedTurnOnHandler(evt) 
{
    def callMethod = "motionDetectedTurnOnHandler"
    state.lastmotiontime = new Date().format('yyyy-MM-dd, HH:mm:ss')               
    //loginfo("last motion ${  state.lastmotiontime }", callMethod)  
    
    loginfo("motion detected on turn op device, unscheduling checkMotionAndTurnOff", callMethod)
    unschedule(checkMotionAndTurnOff)
    
    if(aboutRoom == "h"){ handleHallway() }
    else if(aboutRoom == "mb"){ handleMasterBedroom() }
    else if(aboutRoom == "lr"){ handleLivingRoom() }
    else if(aboutRoom == "o"){ handleOffice() }
    else if ( ["g", "k"].contains(aboutRoom) ) { handleSimpleMotion() }
    //else if ( ["w", "s"].contains(aboutRoom) ) { handleSimpleDoor() }
}

def motionStoppedTurnOnHandler(evt) 
{
    def callMethod = "motionStoppedTurnOnHandler"
}


def motionDetectedKeepOnHandler(evt) 
{
    def callMethod = "motionDetectedKeepOnHandler"
    if(isAnySwitchOn(mainlights) || isAnySwitchOn(sidelights)) //WILL THIS CAUSE TROUBLE?
    {

    }
    
    loginfo("motion detected on keep op device, unscheduling checkMotionAndTurnOff", callMethod)
    unschedule(checkMotionAndTurnOff)            

    state.motiondetectedkeeponunscheduletime = new Date().format('yyyy-MM-dd, HH:mm:ss')               
}



def motionStoppedKeepOnHandler(evt) 
{
    def callMethod = "motionStoppedKeepOnHandler"
    //def configs = getConfig(getMode(), "mainlights", "dark")
    //TEST IF LIGHTS ARE ON?
    if(isAnySwitchOn(mainlights) || isAnySwitchOn(sidelights))
    {
        if ( ["h","lr","mb","k", "g", "o"].contains(aboutRoom) ) //ROOMS WITH MOTION SENSORS
        {
            if(state.stayon > 0 && state.stayon != null )
            {
                unschedule(checkMotionAndTurnOff)
                state.motionstoppedkeeponunscheduletime = new Date().format('yyyy-MM-dd, HH:mm:ss')               
                
                runIn(state.stayon, checkMotionAndTurnOff)
                
                loginfo("lights off in ${state.stayon}s", callMethod)
                
                state.motionlesstime = new Date().format('yyyy-MM-dd, HH:mm:ss');               
                loginfo("motionless ${  state.motionlesstime }", callMethod)
                def newTime = new Date(new Date().time + (state.stayon * 1000)) 
                state.turnofftime = newTime.format('yyyy-MM-dd, HH:mm:ss')
                loginfo("lights will go off at ${  state.turnofftime }", callMethod)
            }    
            else
            {
                //loginfo("state.stayon == ${state.stayon}", "motionStoppedKeepOnHandler")
            }
        }
    }
}

def powerChangedHandler(evt)
{
    def callMethod = "powerChangedHandler"
    def currentPower = evt.value as Double  // Current power usage in watts
    def lastPower = state.lastPower ?: 0    // Previous power usage stored in state
    // Check if the change exceeds 30 watts
    def powerDifference = Math.abs(currentPower - lastPower)

    if (powerDifference > 30) 
    {
        logdebug ("powerChanged: ${evt.value}","powerChangedHandler", callMethod)
        logdebug ("Power change detected: current = ${currentPower}W, previous = ${lastPower}W, difference = ${powerDifference}W, threshold = ${powerThreshold}",callMethod)
        logdebug ("Power change exceeds 30W, taking action",callMethod)
        if(aboutRoom == "lr"){ handleLivingRoom() }
    }

}

def luxChangedHandler(evt) 
{
    def callMethod = "luxChangedHandler"
    /*
    def anylightson = isAnySwitchOn(mainlights)
    logdebug ("lux level ${evt?.displayName} (virt: ${isVirtual(evt?.device)}) changed to ${evt.value}, threshold is ${luxThreshold}, any lights on: ${anylightson}", "luxChangedHandler")
    if(anylightson)
    {
        logdebug "some lights are on"
        if (evt?.device.currentIlluminance >= luxThreshold) {
            logdebug "${isVirtual(evt?.device) ? "virtual" : "real"} lux is now above threshold, turning off lights if no motion."
           // extendSchedule(getStayOnState(), turnOffIfInactive)
        }
    }
*/
    
    if(aboutRoom == "h")
    {
        //handleHallway()
    }        
    
}

def switchesHandler(evt)
{
    def callMethod = "switchesHandler"
    /*
    def anylightson = isAnySwitchOn(mainlights)
    logdebug ("switch change ${evt?.displayName} (virt: ${isVirtual(evt?.device)}) changed to ${evt.value}, any lights on: ${anylightson}", "switchesHandler")
    if(anylightson)
    {
        logdebug "${isVirtual(evt?.device) ? "virtual" : "real"} ${evt?.displayName}, some lights are on, turning off lights if no motion."
       // extendSchedule(getStayOnState(), turnOffIfInactive)
    }
*/
    if(aboutRoom == "h")
    {
        //handleHallway()
    }     
}


def lightSwitchedOnHandler(evt)
{
    def callMethod = "lightSwitchedOnHandler"
    loginfo("manuallyOverrideEnable: ${manuallyOverrideEnable}", callMethod)
    if(manuallyOverrideEnable)
    {
        def nowTime = now()
        def lastAutomation = state.lastautomation ?: 0
        def elapsedTime = nowTime - lastAutomation

        if (elapsedTime > 3000) // 3 seconds threshold for "manual" assumption
        { 
            loginfo("Light was turned on manually.", callMethod)
            state.turnedonmanually = true
            // Add your manual action handling here
        } else {
            loginfo("Light was turned on automatically.", callMethod)
        }      
    }
}

def lightSwitchedOffHandler(evt)
{
    def callMethod = "lightSwitchedOffHandler"
    if(state.turnedonmanually)
    {
        loginfo("Light turned off manually. Resetting automation flag.", callMethod)
    }
    state.turnedonmanually = false
}


def lightSwitchesHandler(evt)
{
    def callMethod = "lightSwitchesHandler"
    if(aboutRoom == "o")
    {
        handleOffice()
    }
}


def modeChangedHandler(evt) {
    def callMethod = "modeChangedHandler"
    //logdebug("mode to <b>${evt.displayName}</b>", "modeChangedHandler")
    def currentMode = getMode()
    logdebug("mode to <b>${currentMode}</b>", callMethod)
    
    def states = allStates()
    if( ["SleepAll", "Away"].contains(currentMode))
    {
        turnOffLights()
        logdebug("mode = ${currentMode}, all lights off",callMethod)
    }     
    else if( ["SleepSome"].contains(currentMode) && ["h","mb"].contains(aboutRoom))
    {
        turnOffLights()
    }
}

def roomDoorsHandler(evt) 
{
    def callMethod = "roomDoorsHandler"
    logdebug("${evt.device} IS ${isContactOn(evt.device) ? "OPEN" : "DICHT"} : ${evt?.value}", callMethod)
    //if(isContactOn(evt.device))
    
    if(aboutRoom == "h"){ handleHallway() }
    else if ( ["w", "s"].contains(aboutRoom) ) { handleSimpleDoor() }    
}

def houseDoorsHandler(evt) 
{
    def callMethod = "houseDoorsHandler"
    logdebug("${evt.device} IS ${isContactOn(evt.device) ? "OPEN" : "DICHT"} : ${evt?.value}", callMethod)
    if(aboutRoom == "h"){ handleHallway() }
}

def buttonTurnOnPushedHandler(evt) 
{
    def callMethod = "buttonTurnOnPushedHandler"
    logdebug("button ${evt?.displayName} ${evt?.value}", callMethod)
    if(aboutRoom == "h"){ handleHallway("pushsingle") }
    else if(aboutRoom == "mb"){ handleMasterBedroom("pushsingle") }  
}

def buttonTurnOnDoubleTappedHandler(evt) 
{
    def callMethod = "buttonTurnOnDoubleTappedHandler"
    logdebug("button ${evt?.displayName} ${evt?.value}", callMethod)    
    if(aboutRoom == "h"){ handleHallway("pushdouble") }
    else if(aboutRoom == "mb"){ handleMasterBedroom("pushdouble") }  
}

def buttonTurnOnHeldHandler(evt) 
{
    def callMethod = "buttonTurnOnHeldHandler"
    logdebug("button ${evt?.displayName} ${evt?.value}", callMethod)    
    if(aboutRoom == "h"){ handleHallway("pushheld") }
    else if(aboutRoom == "mb"){ handleMasterBedroom() }
}

//LIGHTS
void turnOnLights(states, configs, lights, comment = "")
{
    def callMethod = "turnOnLights"
    state.lastautomation = now()
    state.lastautomationtime = new Date().format('yyyy-MM-dd, HH:mm:ss')
    state.lasttrigger = configs.base
    state.lasttriggertime = new Date().format('yyyy-MM-dd, HH:mm:ss')
    state.lastmeasuredlux = states.lux
    state.stayon = configs.values.stayon
    lights.each { light ->
        if(isColorDevice(light))
        {
            def hsl = hexToHSL(configs.values.color)
            light.setColor([hue: hsl.hue, saturation: hsl.saturation, level: configs.values.brightness])
            logdebug ("hsl: ${hsl}", callMethod)
        }
        else
        {
            light.setLevel(configs.values.brightness)
            logdebug ("level: ${configs.values.brightness}", callMethod)
        }
        //logdebug "[${allStates().collect { "${it.key} : ${it.value}" }.join("] [")}]"
        //loginfo "ON ${light.displayName} [${light.collect { "${it.key} : ${it.value}" }.join("] [")}]"        
        loginfo("ON ${light.displayName} [${configs.do}], ${comment}", callMethod)
    }      
}

def turnOffLights() 
{
    def callMethod = "turnOffLights"
    if(state.turnedonmanually)
    {
        loginfo("Automation attempted to turn off the light, but it was left on due to manual override.", callMethod)
    }
    else
    {
        mainlights?.off()
        sidelights?.off()
        loginfo ("Turning off all room lights automatically",callMethod)    
    }
}

def turnOffGrpLights(lights) 
{
    def callMethod = "turnOffGrpLights"
    if(state.turnedonmanually)
    {
        loginfo("Automation attempted to turn off the light, but it was left on due to manual override.",callMethod)
    }
    else    
    {
        lights?.off()
        loginfo ("Turning off room lights automatically",callMethod)    
    }
}

def checkMotionAndTurnOff() 
{
    def callMethod = "checkMotionAndTurnOff"

    if (!isAnyMotionActive(motionSensorsKeepOn)) 
    {
        loginfo ("No motion, turning off",callMethod)    
        turnOffLights()
        unschedule(checkMotionAndTurnOff)
    } 
    else 
    {
        unschedule(checkMotionAndTurnOff)
        loginfo ("Motion, rescheduling turning off",callMethod)    
        runIn(state.stayon, checkMotionAndTurnOff) // Check again after 1 minute if motion persists
    }
    
}

//SMALL FUNCTIONS
def isVirtual(device) {
    return device?.getTypeName()?.toLowerCase()?.contains("virtual") ?: false
}

def isAnySwitchOn(devices)
{
    def anyOn = devices.find { it.currentValue("switch") == "on" }
    return anyOn != null
}
def isAnyContactOn(devices)
{
    def anyOpen = devices.find { isContactOn(it) }
    return anyOpen != null
}
def isContactOn(device) {
    return device.currentValue("contact") == "open"
}
def isColorDevice(device) {
    return device.hasCapability("ColorControl")
}

def isMotionActive(device) {
    return device.currentMotion == "active"
}
def isAnyMotionActive(devices)
{
    def anyActive = devices.find { it.currentMotion == "active" }
    return anyActive != null
}



/*
def getLightValues(lights) {
    lights?.each { light ->
        def switchState = isSwitchOn(light) // On or Off
        def brightnessLevel = light.currentValue("level") // Brightness level (0-100)
        def color = light.currentValue("color") // Color (if applicable)
        loginfo "Device: ${light.displayName}, Switch: ${switchState}, Brightness: ${brightnessLevel}, Color: ${color ?: 'N/A'}"
    }
}
*/

/*
def graduallyChangeLightToLevel(device, targetLevel, duration) {
    def currentLevel = device.currentValue("level") ?: 0
    logInfo "Current brightness: ${currentLevel}, Target brightness: ${targetLevel}"
    
    def stepCount = 10 // Number of steps to make the transition smooth
    def stepDuration = (duration * 1000) / stepCount // Convert duration to milliseconds and divide by steps
    def stepSize = (targetLevel - currentLevel) / stepCount // Determine how much to change per step

    (1..stepCount).each { step ->
        def newLevel = Math.round(currentLevel + (step * stepSize)) // Calculate the new brightness level
        device.setLevel(newLevel)
        logDebug "Step ${step}: Setting brightness to ${newLevel}"

        pauseExecution(stepDuration) // Wait for the step duration before the next step
    }

    logInfo "Light reached target brightness: ${targetLevel}"
}
*/

def isTimeBetween(timeStart, timeEnd) {
    def now = new Date()
    def start = parseTime(timeStart)
    def end = parseTime(timeEnd)

    // Adjust end time if it is before the start time (for times that cross midnight)
    if (end < start) {
        end += 24 * 60 * 60 * 1000 // add a day in milliseconds
    }

    return now >= start && now <= end
}

def parseTime(timeStr) {
    def timeParts = timeStr.split(':')
    def now = new Date()
    return new Date(now.year, now.month, now.date, timeParts[0].toInteger(), timeParts[1].toInteger())
}

def hexToHSL(hex) {
    // Remove the # symbol if present
    hex = hex.replace("#", "")

    // Convert hex to RGB
    int r = Integer.valueOf(hex.substring(0, 2), 16)
    int g = Integer.valueOf(hex.substring(2, 4), 16)
    int b = Integer.valueOf(hex.substring(4, 6), 16)

    float rPct = r / 255.0
    float gPct = g / 255.0
    float bPct = b / 255.0

    float max = Math.max(rPct, Math.max(gPct, bPct))
    float min = Math.min(rPct, Math.min(gPct, bPct))

    float h = 0
    float s = 0
    float l = (max + min) / 2

    if (max != min) {
        float d = max - min
        s = (l > 0.5) ? d / (2.0 - max - min) : d / (max + min)

        if (max == rPct) {
            h = (gPct - bPct) / d + (gPct < bPct ? 6 : 0)
        } else if (max == gPct) {
            h = (bPct - rPct) / d + 2
        } else if (max == bPct) {
            h = (rPct - gPct) / d + 4
        }

        h /= 6
    }

    h = Math.round(h * 100)
    s = Math.round(s * 100)
    l = Math.round(l * 100)

    return [hue: h, saturation: s, level: l]
}

def getConfig(modename, lightname, statename)
{
    def callMethod = "getConfig"
    def result = []

    if ([lightname, statename, modename].every { it != null }) 
    {
        def isValidLight = lightGroupArray().any { it[0] == lightname }
        def isValidState = stateGroupArray().any { it[0] == statename } 
        if(isValidLight && isValidState)
        {
            def l = lightGroupArray().find { it[0] == lightname }[1]
            def s = stateGroupArray().find { it[0] == statename }[1]
            //logdebug l
            //logdebug s
            def stateDescription = "${statename}: ${s}"
            def base = "${modename}_${lightname}_${statename}"
            def titleGrpState = "[${modename.toUpperCase()}-ðŸ’¡${l.toLowerCase()}] ${s.toLowerCase()}"
            result = [
                statedescription: stateDescription,
                title: titleGrpState,
                base: "${base}",
                do: "${base}_do",
                turnon: "${base}_turn_on",
                forcechange: "${base}_forcechange",
                brightness: "${base}_brightness",
                color: "${base}_color",
                stayon: "${base}_stayon",
                lightname: lightname,
                values: [
                    do: settings["${base}_do"],
                    turnon: settings["${base}_turn_on"],
                    forcechange: settings["${base}_forcechange"],
                    brightness: settings["${base}_brightness"],
                    color: settings["${base}_color"],
                    stayon: settings["${base}_stayon"],
                ]
                //def result = settings[${turnon}]
            ]
        }
        else
        {
            logdebug ("âŒnot found in arrays, modename: ${modename}, lightname : ${lightname} : ${isValidLight}, statename: ${statename} : ${isValidState}", callMethod)
        }
    }
    else
    {
        result = []
    }    
    return result
}

def allStates()
{
    def currentmode = getMode()
    def isDarkCombi = ( isDarkSwitch?.currentValue("switch") == "on" || luxSensor?.currentIlluminance < luxThreshold) 
    return [mode:currentmode,
            isvalidmode: (includedModes && includedModes.contains(currentmode)),            
            darkon: isDarkSwitch?.currentValue("switch") == "on",
            lux: luxSensor?.currentIlluminance,
            luxThreshold:luxThreshold,
            luxlow:luxSensor?.currentIlluminance < luxThreshold,
            isDark: isDarkCombi,
            isDarkOrNoCfg : isDarkCombi ? "dark" : "no",
            isAnyLightOnMain : isAnySwitchOn(mainlights),
            isAnyLightOnSide : isAnySwitchOn(sidelights),
            isOpenRoomDoor:isAnyContactOn(roomDoors),
            isOpenHouseDoor:isAnyContactOn(houseDoors),
            isMotion:isAnyMotionActive(motionSensorsKeepOn),
            socketPlugPower:socketPlug?.currentValue("power"),
            isSocketPlugUsingPower:socketPlug?.currentValue("power") > powerThreshold,
            isWeekDay: ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
            isEarlyWorkTime: isTimeBetween("04:20", "05:30") && ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
            //isEarlyWorkTime: isTimeBetween("13:05", "13:07") && ["Mon", "Tue", "Wed", "Thu", "Fri"].contains(new Date().format("E", location.timeZone)),
            ]
}
